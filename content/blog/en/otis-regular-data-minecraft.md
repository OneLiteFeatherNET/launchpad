---
title: 'Otis: Central player data for Minecraft (Java & Micronaut)'
alternativeTitle: 'Mojang UUID v4, internal UUID v7, name & language as a stable base for the ecosystem'
description: 'Otis provides central player master data: Mojang UUID (v4), internal UUID (v7), Minecraft name, language, and optionally first/last join. This cuts manual one-off processes, supports GDPR-oriented data flows, and forms the foundation for downstream services like metadata, bans, and Discord bots.'
pubDate: '2025-11-29'
headerImage: 'images/blog/otis-player-data-header.png'
headerImageAlt: 'Otis Microservice: central Minecraft player data (Java, Micronaut)'
slug: 'otis-central-player-data-minecraft'
translationKey: 'otis'
tags:
  - minecraft
  - data
  - microservices
author: phillipp-glanz

canonical: 'https://onelitefeather.net/en/blog/otis-central-player-data-minecraft'
alternates:
  - hreflang: 'de'
    href: 'https://onelitefeather.net/de/blog/otis-zentrale-spielerstammdaten-minecraft'
  - hreflang: 'en'
    href: 'https://onelitefeather.net/en/blog/otis-central-player-data-minecraft'
  - hreflang: 'x-default'
    href: 'https://onelitefeather.net/en/blog/otis-central-player-data-minecraft'

schemaOrg:
  - type: 'BlogPosting'
    headline: 'Otis: Central player data for Minecraft'
    alternativeHeadline: 'Java/Micronaut microservice for UUIDs, name, and language'
    description: 'Central player data as an interface in the ecosystem: fewer manual data islands, clearer responsibilities, and a base for reliable services.'
    author:
      type: 'Person'
      name: 'Phillipp Glanz'
    datePublished: '2025-11-29T00:00:00+00:00'

---

## Preamble

---

## Preamble

From a developer perspective, we lack a single source of truth for player lookup, converting names to UUIDs, and processing internal data for downstream systems. Without Otis, devs pull data from scattered sources (own/third-party DBs and services) or roll their own, which leads to duplicate data, inconsistent deletions (bad for GDPR), and tangled dependencies—sysadmins can lose track during migrations.

Admins and moderators also face extra overhead without a shared source: network-wide bans/unlocks, tracking name changes, and coordination with players become harder.

Decentralized data often arises due to social/organizational gaps: early projects have few devs, rely on third-party plugins, or multiple minigame teams prototype in isolation without shared standards. Minigames like “Bedwars” and “SkyPvP” may both need player name/UUID, IP, language, textures, scores, currencies, etc. If no central interface exists, teams improvise, duplicate data, or depend on “core” plugins that become heavy hard dependencies and lag behind API updates. High team turnover and missing docs worsen this.

Technical hurdles: uneven knowledge and missing shared API standards can produce fragile or unusable “core” interfaces. Good APIs need clarity and stability; otherwise, devs avoid them and build their own.

**TL;DR: Central services depend on technical and social decisions; communication is step one.**

Otis doesn’t aim to be a universal player DB; it stores what our team deems essential. Newcomers must learn Otis early to avoid reinventing data stores.

Alternatives like a shared NoSQL DB suffer from duplicate fields (e.g., differing UUIDs per mode) and lack archiving. We haven’t found an open-source fit for our use case.

---

## Solution

Otis exposes an interface to manage player master data. It autonomously handles key fields like player UUID, first/last network join, and player name.

Technically, Otis uses a [layered architecture](https://en.wikipedia.org/wiki/Multitier_architecture) with [microservice](https://en.wikipedia.org/wiki/Microservices) principles in a [stateless](https://en.wikipedia.org/wiki/Stateless_protocol) design. In Gradle, we split backend, client, and Velocity plugin. The Velocity plugin uses the client; the client is generated from the backend’s OpenAPI spec. The backend itself has three layers: DTOs/controllers (client comms), service layer (validation/enrichment), and data layer (“repository”).

<img src="https://upload.wikimedia.org/wikipedia/commons/e/e1/SchichtenarchitekturAufrufstrukturen.svg" class="dark:bg-white/85 bg-white" alt="Schichtenarchitektur Aufrufstrukturen" />

### DTOs

Data Transfer Objects carry OpenAPI annotations for autogenerated docs. Validation groups ensure constraints (e.g., max 16 chars for names, no negative timestamps) and let us return explicit responses without server stack traces—keeping internals safer.

### Service layer

Requests land in the service layer, which validates/enriches data before persistence. It can set internal fields not exposed externally—effectively the “switchboard.”

### Data layer

The data layer holds entities and queries defining storage structure.

### Why layered + microservice?

This keeps the MVP focused, fast, and clean. With microservices we stay platform-agnostic: Minestom, Bedrock, Paper, Fabric/Forge, etc., all talk via a single REST interface.

A good use case is Minecraft, but any game with stable player IDs could integrate; other platforms (forums, Discord bots) can also plug in.

### Possible issues

Stateless calls mean DB hits are precious. Heavy parallel access can hurt availability/latency (ideally 5–15 ms DB response). Caching (shared across instances for horizontal scaling) helps; vertical scaling by just adding CPU/RAM is not ideal for us.

---

## Closing

This project gives us a solid base to tackle other efforts and deepen our understanding of architecture and communication. Otis can be reused for other (Minecraft) projects to gain stability, consistency, and maintainability. Questions? Ping us on Discord. Constructive feedback on this post is welcome.
